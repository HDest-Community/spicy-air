class SpicyAirHandler : HDCoreStaticEventHandler {

    int BreathIndex[MAXPLAYERS];
    int BreathHoldTimer[MAXPLAYERS];
    double AirSpiciness[MAXPLAYERS];
    int RealSpiciness[MAXPLAYERS];
    int SpicyLevel[MAXPLAYERS];

    // List of map names to completely ignore.
    Array<name> mapBlacklist;

    // List of persistent classes to completely ignore.
    Array<name> thingBlacklist;

    // List of ClassNames to consider to add spicy
    Array<name> spicySources;

    // List of ClassNames to consider to remove spicy
    Array<name> spicySinks;

    private transient Service _HHFunc;
    private transient Service _RespService;
    private transient Service _SpicyService;

    private transient CVar _enabled;

    private transient CVar _losFactor;

    private transient CVar _actorSectorRatio;
    private transient CVar _distCalc;

    private transient CVar _damageType;
    private transient CVar _maxSpiciness;

    private transient CVar _underwaterClean;

    private transient CVar _bossesSpicySources;
    private transient CVar _friendliesSpicySources;
    private transient CVar _monstersSpicySources;
    private transient CVar _shieldsSpicySources;

    private transient CVar _spicySinkDistance;
    private transient CVar _spicySourceDistance;

    private transient CVar _damageThreshold;
    private transient CVar _radsuitProtection;
    private transient CVar _hhelmetProtection;

    override void beforeProcessCommands() {
        if (!_HHFunc) _HHFunc                                 = ServiceIterator.Find("HHFunc").Next();
        if (!_RespService) _RespService                       = ServiceIterator.Find("UaS_RespiratorStatus").Next();
        if (!_SpicyService) _SpicyService                     = ServiceIterator.Find("SpicyAirService").Next();

        if (!_enabled) _enabled                               = CVar.GetCVar('spicy_enabled');

        if (!_losFactor) _losFactor                           = CVar.GetCVar('spicy_los_factor');

        if (!_actorSectorRatio) _actorSectorRatio             = CVar.GetCVar('spicy_actor_sector_ratio');
        if (!_distCalc) _distCalc                             = CVar.GetCVar('spicy_dist_calc');

        if (!_damageType) _damageType                         = CVar.GetCVar('spicy_damage_type');
        if (!_maxSpiciness) _maxSpiciness                     = CVar.GetCVar('spicy_max_spiciness');

        if (!_damageThreshold) _damageThreshold               = CVar.GetCVar('spicy_damagethreshold');
        if (!_radsuitProtection) _radsuitProtection           = CVar.GetCVar('spicy_radsuitprotection');
        if (!_hhelmetProtection) _hhelmetProtection           = CVar.GetCVar('spicy_hhelmetprotection');
        
        if (!_underwaterClean) _underwaterClean               = CVar.GetCVar('spicy_underwater_clean');

        if (!_bossesSpicySources) _bossesSpicySources         = CVar.GetCVar('spicy_sources_bosses');
        if (!_friendliesSpicySources) _friendliesSpicySources = CVar.GetCVar('spicy_sources_friendlies');
        if (!_monstersSpicySources) _monstersSpicySources     = CVar.GetCVar('spicy_sources_monsters');
        if (!_shieldsSpicySources) _shieldsSpicySources       = CVar.GetCVar('spicy_sources_shields');

        if (!_spicySinkDistance) _spicySinkDistance           = CVar.GetCVar('spicy_sink_distance');
        if (!_spicySourceDistance) _spicySourceDistance       = CVar.GetCVar('spicy_source_distance');
    }

    override void processCommand(HDCoreCommand cmd) {
        
        switch (cmd.command) {
            case 'addSpicyMapBlacklist': {
                let name = cmd.getNameParam("name");

                if (name && mapBlacklist.find(name) == mapBlacklist.size()) mapBlacklist.push(name);
                break;
            }
            case 'removeSpicyMapBlacklist': {
                let name = cmd.getNameParam("name");

                if (name && mapBlacklist.find(name) < mapBlacklist.size()) mapBlacklist.delete(mapBlacklist.find(name));
                break;
            }
            case 'clearSpicyMapBlacklist': {
                mapBlacklist.clear();
                break;
            }
            case 'addSpicyThingBlacklist': {
                let name = cmd.getNameParam("name");

                if (name && thingBlacklist.find(name) == thingBlacklist.size()) thingBlacklist.push(name);
                break;
            }
            case 'removeSpicyThingBlacklist': {
                let name = cmd.getNameParam("name");

                if (name && thingBlacklist.find(name) < thingBlacklist.size()) thingBlacklist.delete(thingBlacklist.find(name));
                break;
            }
            case 'clearSpicyThingBlacklist': {
                thingBlacklist.clear();
                break;
            }
            case 'addSpicySource': {
                let name = cmd.getNameParam("name");

                if (name && spicySources.find(name) == spicySources.size()) spicySources.push(name);
                break;
            }
            case 'removeSpicySource': {
                let name = cmd.getNameParam("name");

                if (name && spicySources.find(name) < spicySources.size()) spicySources.delete(spicySources.find(name));
                break;
            }
            case 'clearSpicySources': {
                spicySources.clear();
                break;
            }
            case 'addSpicySink': {
                let name = cmd.getNameParam("name");

                if (name && spicySinks.find(name) == spicySinks.size()) spicySinks.push(name);
                break;
            }
            case 'removeSpicySink': {
                let name = cmd.getNameParam("name");

                if (name && spicySinks.find(name) < spicySinks.size()) spicySinks.delete(spicySinks.find(name));
                break;
            }
            case 'clearSpicySinks': {
                spicySinks.clear();
                break;
            }
            default: 
                break;
        }
    }

    override void afterProcessCommands() {
        if (HDCore.ShouldLog('SpicyAir.SpicyAirHandler', LOGGING_DEBUG)) {

            let msg = "Configured Spicy Sinks:\n";
            
            forEach(sink : spicySinks) msg = msg.." * "..sink.."\n";
            
            HDCore.Log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, msg);
            

            msg = "Configured Spicy Sources:\n";
            
            forEach(source : spicySources) msg = msg.." * "..source.."\n";
            
            HDCore.Log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, msg);
        }
    }

    override void WorldLoaded(WorldEvent e) {

        super.WorldLoaded(e);

        if (e.IsReopen) return;

        // Initialize  Status
        for (int i = 0; i < MAXPLAYERS; i++) {
            BreathIndex[i] = 0;
            AirSpiciness[i] = 0;
            RealSpiciness[i] = 0;
            SpicyLevel[i] = 0;
            BreathHoldTimer[i] = Level.AirSupply; // * players[i].mo.AirCapacity;
        }
    }

    override void RenderUnderlay(RenderEvent e) {

        // Grab the current player and if they don't exist or are invisible, quit.
        let plr = HDPlayerPawn(e.Camera);
        if (!plr || plr.bINVISIBLE || plr.bSHADOW) return;

        // Check if the player has either a Gas Mask or Helmet equipped.
        let mask = Despicyto(plr.FindInventory('Despicyto'));
        bool hasHelmet = _HHFunc && _HHFunc.GetIntUI("GetShowHUD", objectArg: plr);

        if (
            (
                (mask && mask.Worn)
                || (hasHelmet && _hhelmetProtection.GetInt() > 0)
            )
            && !automapactive
        ) {
            int MaskHeight = int(Screen.GetHeight() * 2.2);
            int MaskWidth = int(Screen.GetWidth() * MaskHeight * 1.2) / Screen.GetHeight();
            int MaskOffX = -((MaskWidth - Screen.GetWidth()) >> 1);
            int MaskOffY = -((MaskHeight - Screen.GetHeight()) >> 1);

            let goggles = PortableLiteAmp(plr.FindInventory('PortableLiteAmp'));

            // Only handle breathing animation if Spicy Air is enabled
            if (_enabled.GetBool()) {
                double breathFactor = BreathIndex[plr.PlayerNumber()] / double(GetBreathDelay(plr));
                double breathAlpha = clamp(CVar.GetCVar('spicy_breathalpha', players[plr.PlayerNumber()]).GetFloat(), 0.0, 1.0);
                breathFactor = 0.1 + min(1.0, abs(breathFactor > 0 ? breathFactor * 2.25 : breathFactor)) * breathAlpha;

                if (goggles && goggles.worn) {
                    breathFactor *= 0.1 - (goggles.amplitude / PortableLiteAmp.NITEVIS_MAX) * 0.05;
                }

                if (breathFactor > 0.0) {
                    Screen.DrawTexture(
                        TexMan.CheckForTexture("DESPMOIS"),
                        true,
                        MaskOffX - (int(plr.wepbob.x * 0.5)),
                        MaskOffY - (int(plr.wepbob.y * 0.5)),
                        DTA_Alpha, breathFactor,
                        DTA_DestWidth, MaskWidth,
                        DTA_DestHeight, MaskHeight
                    );
                }
            }

            // Rendering the Overlay can happen even if the mod is disabled,
            // as the gas mask feels a bit pointless otherwise.
            double maskAlpha = clamp(CVar.GetCVar('spicy_gasmaskalpha', players[plr.PlayerNumber()]).GetFloat(), 0.0, 1.0);
            if ((mask && mask.Worn) && !(goggles && goggles.worn) && maskAlpha > 0.0) {
				Screen.DrawTexture(
                    TexMan.CheckForTexture("DESPMASK"),
                    true,
                    MaskOffX - (int(plr.wepbob.x * 0.5)),
                    MaskOffY - (int(plr.wepbob.y * 0.5)),
                    DTA_Alpha, maskAlpha,
                    DTA_DestWidth, MaskWidth,
                    DTA_DestHeight, MaskHeight
                );
            }
        }
    }

    override void WorldTick() {

        // If we can't find the CVAR, or it's not set to true, or the level is frozen, quit.
        if (!(_enabled && _enabled.GetBool()) || Level.IsFrozen()) return;
        
        // TODO: Refactor following logic into separate functions
        for (int i = 0; i < MAXPLAYERS; i++) {
            let plr = HDPlayerPawn(players[i].mo);

            // If the player isn't an HDPlayerPawn or is dead, skip.
            if (!plr || plr.Health <= 0) continue;

            let mask = Despicyto(plr.FindInventory('Despicyto'));
            bool hasHelmet = _HHFunc && _HHFunc.GetInt("GetShowHUD", objectArg: plr);
            bool wearingRespirator = _RespService && _RespService.GetInt("IsWorn", objectArg: plr);
            bool respiratorAir = _RespService && _RespService.GetInt("AirRemaining", objectArg: plr);

            // Store the raw air spiciness for service to provide.
            AirSpiciness[i] = !(IsAirClean(plr) || (mask && mask.worn)) ? GetAirSpiciness(plr) : 0.0;

            // If the player has godmode on, clear their spiciness and skip.
            if (plr.player.cheats&(CF_GODMODE2|CF_GODMODE)) {
                plr.A_TakeInventory('SpicyAirDrug');
                RealSpiciness[i] = 0;
                continue;
            }

            // Handle Player Breathing
            // -----------------------
            // The player is "currently breathing" if:
            // - They are not submerged underwater, or if they are, they're wearing a UaS Respirator and it has air in it
            // - They are wearing a gas mask
            // - They are wearing a Hideous Helmet and it provides protection against spicy air
            // TODO: add manual breath holding?
            bool isBreathing = true;
            int bDelay = GetBreathDelay(plr);
            if (plr.WaterLevel < 3 || (wearingRespirator && respiratorAir > 0)) {
                BreathIndex[i]++;

                if (BreathIndex[i] >= bDelay) BreathIndex[i] = -bDelay;
            } else {
                isBreathing = false;
                BreathIndex[i] = 0;
            }

            // Display Visual/Auditory Feedback of breathing
            // TODO: Refactor into commands to define what constitutes "covered face/breathing"
            if ((mask && mask.Worn) || (hasHelmet && _hhelmetProtection.GetInt() > 0)) {
                int bSpeed = GetBreathSpeed(plr);

                double vol = clamp(CVar.GetCVar('spicy_breathingvolume', players[i]).GetFloat(), 0, 1);
                
                if (vol > 0) {
                    if (BreathIndex[i] == 0) {
                        plr.A_StartSound("SpicyAir/Mask/BreatheOut"..bSpeed, 35, CHANF_LOCAL, vol, pitch: frandom[spicyrand](0.97, 1.0));
                    } else if (BreathIndex[i] == -bDelay) {
                        plr.A_StartSound("SpicyAir/Mask/BreatheIn"..bSpeed, 36, CHANF_LOCAL, vol, pitch: frandom[spicyrand](0.97, 1.0));
                    }
                }
            }

            // Handle Air Toxicity Logic
            // -------------------------
            // - If the air being breathed in is clean, adjust "breath hold timer" depending if the player is underwater or wearing a respirator providing air
            // - If the air being breathed in is clean or filtered, reduce spiciness while the player is breathing out
            // - If the air being breathed in is not clean nor filtered, if the player has breath left to hold, reduce timer; otherwise add spiciness while the player is breathing in
            // - If the player has gathered enough spiciness in their system, increase their spicy level
            // - As long as the player still has some amount of spiciness levels in their system, every time the timer ticks, add aggro based on their spicy level

            if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "[Player #"..(i + 1).."] Air Spiciness: "..AirSpiciness[i]);

            // adjust the player's raw spiciness level.
            if (
                // TODO: Add check for manually holding breath?
                (plr.waterLevel < 3 || (wearingRespirator && respiratorAir > 0)) && isBreathing
            ) {
                // TODO: Enhance to track UaS Respirator being filled in spicy air,
                //   later breathing from same respirator should give roughly percent spiciness from last refill
                let toAdd = frandom[spicyrand](0.01, 0.1) * abs(AirSpiciness[i] - RealSpiciness[i]);
                let filterBonus = _spicyService.getDouble("GetFilterBonus", objectArg: plr);

                if (BreathIndex[i] == -bDelay || BreathIndex[i] == 0) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "[Player #"..(i + 1).."] Breathing "..(BreathIndex[i] < 0 ? "in" : "out").." "..toAdd.."x Spiciness");

                RealSpiciness[i] += BreathIndex[i] < 0 ? (toAdd * clamp(1.0 - filterBonus, 0.0, 1.0)) : -toAdd;

                if (BreathIndex[i] < 0 && !random[spicyrand](0, abs(BreathIndex[i]))) {
                    if (mask && mask.Worn) {
                        let hasLeftFilter  = mask.weaponStatus[DEProp_FilterLife1] > 0;
                        let hasRightFilter = mask.weaponStatus[DEProp_FilterLife2] > 0;

                        if (hasLeftFilter || hasRightFilter) {
                            let filterDmg = toAdd / max(1, hasLeftFilter + hasRightFilter);

                            if (hasLeftFilter)  mask.weaponStatus[DEProp_FilterLife1] -= filterDmg;
                            if (hasRightFilter) mask.weaponStatus[DEProp_FilterLife2] -= filterDmg;
                        }
                    }
                }
            }

            // Clamp lung spiciness
            RealSpiciness[i] = clamp(RealSpiciness[i], 0, Level.airSupply * _maxSpiciness.GetInt());

            if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "[Player #"..(i + 1).."] Lung Spiciness: "..RealSpiciness[i]);
            
            // Convert spiciness in lungs to SpicyAirDrug on heartbeat
            let playerSpiciness = plr.countInv('SpicyAirDrug');
            if (playerSpiciness < RealSpiciness[i] && !plr.beatcount) {

                let processed = frandom[spicyrand](0.01, 0.1) * abs(RealSpiciness[i] - playerSpiciness);

                if (processed > 0) {
                    HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "[Player #"..(i + 1).."] Converting "..processed.."x Spiciness into SpicyAirDrug");
    
                    HDF.give(plr, 'SpicyAirDrug', processed);
                    RealSpiciness[i] -= processed;
                }
            }
        }
    }

    override void WorldThingSpawned(WorldEvent e) {

        // If we can't find the CVAR or it's not set to true, quit.
        if (!(_enabled && _enabled.GetBool())) return;

        // If the thing doesn't exist, quit.
        if (!e.thing) return;

        let mo = e.thing;

        // If the thing is blacklisted, quit.
        forEach (bl : thingBlacklist) if (mo is bl) return;

        // If the current map is blacklisted, quit.
        forEach (bl : mapBlacklist) if (Level.mapName == bl) return;
        
        // Mark if the thing is sink.
        let isSink = false;
        forEach (sink : spicySinks) {
            if (mo is sink) {
                isSink = true;
                break;
            }
        }
        
        // Mark if the thing is source.
        let isSource = false;
        forEach (source : spicySources) {
            if (mo is source) {
                isSource = true;
                break;
            }
        }

        // If there's no amount to consider or thing is neither sink nor source, quit.
        if (!(isSink || isSource)) return;

        // If the thing has no trackers and is a spicy sink, give it a token.
        if (!(mo.countInv('SpicyAirSourceToken') || mo.countInv('SpicyAirSinkToken')) && isSink) {
            HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "Giving Sink Token to "..mo.getClassName().." @"..mo.pos);

            HDF.give(mo, 'SpicyAirSinkToken');
        }

        // If the thing has no trackers and is a spicy source, give it a token.
        if (!(mo.countInv('SpicyAirSourceToken') || mo.countInv('SpicyAirSinkToken')) && isSource) {
            HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "Giving Source Token to "..mo.getClassName().." @"..mo.pos);

            HDF.give(mo, 'SpicyAirSourceToken');
        }
    }

    // The air is considered clean if:
    //  - The current map is blacklisted
    //  - The player is currently inside of a sector marked as non-spicy
    //  - The player is currently in deep water and doing so is considered clean
    bool IsAirClean(HDPlayerPawn plr) {

        bool cleanLevel = false;
        forEach (bl : mapBlacklist) {
            if (Level.MapName == bl) {
                cleanLevel = true;
                break;
            }
        }

        bool cleanSector = plr.CurSector.GetUDMFInt('user_nonspicysector') == 1;
        bool cleanUnderwater = _underwaterClean.GetBool() && plr.WaterLevel >= 3;

        let ret = cleanLevel|cleanSector|cleanUnderwater;
        
        if (HDCore.shouldLog('SpicyAir.SpicyAirHandler', LOGGING_DEBUG) && !(Level.time % TICRATE)) {
            let msg = ret ? "Air is clean because:\n" : "Ait is not clean";

            if (cleanLevel) msg = msg.." * Current Level is Clean: "..Level.mapName.."\n";
            if (cleanSector) msg = msg.." * Current Sector is Clean: Special\n";
            if (cleanUnderwater) msg = msg.." * Current Sector is Clean: Underwater";
            
            HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_DEBUG, msg);
        }

        return ret;
    }

    bool IsAirFiltered(HDPlayerPawn plr) {
        let mask = Despicyto(plr.FindInventory('Despicyto'));

        return mask && mask.Worn && mask.A_GetTotalAir(false) > 0;
    }

    clearscope int GetBreathDelay(HDPlayerPawn plr) {
        return 90 - int(min(max(plr.fatigue * 2, plr.bloodpressure / 1.3, 110 * (1.0 - plr.beatmax / 35.0)), 80));
    }

    clearscope int GetBreathSpeed(HDPlayerPawn plr) {
        return 3 - int(min(GetBreathDelay(plr) / 35, 2));
    }

    double GetAirSpiciness(HDPlayerPawn plr) {

        double activeSinks = 0.0;
        double activeSources = 0.0;
        int countSinks = 0;
        int countSources = 0;

        int losFactor = _losFactor.GetInt();

		// let iter = BlockThingsIterator.create(plr, 1024);
        let iter = ThinkerIterator.create('Actor');

        if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_TRACE, "BEGIN AIR SPICINESS CALCULATION:");
        Actor mo;
        while (mo = Actor(iter.next())) {
            // Actor mo = iter.thing;

            let blacklisted = false;
            forEach (bl : thingBlacklist) {
                if (mo is bl) {
                    blacklisted = true;
                    break;
                }
            }
            
            // If the thing is blacklisted, skip.
            if (blacklisted) continue;

            // If the thing has an invalid pos, skip.
            if (mo.pos == (-Double.NaN, -Double.NaN, -Double.NaN)) continue;

            // If thing is dead, skip.
            if (mo.health <= 0) continue;

            // If thing is an item and is owned, skip.
            if (mo is 'Inventory' && Inventory(mo).owner && mo.pos == (0, 0, 0)) continue;

            // If thing is a monster when we're not looking for it, skip.
            if (!(_monstersSpicySources.GetBool()) && !mo.bISMONSTER) continue;

            // If thing is friendly when we're not looking for it, skip.
            if (!(_friendliesSpicySources.GetBool()) && mo.bFRIENDLY) continue;

            // If thing is a boss when we're not looking for one, skip.
            if (!(_bossesSpicySources.GetBool()) && mo.bBOSS) continue;

            let sourceAmt = mo.countInv('SpicyAirSourceToken');
            let sinkAmt = mo.countInv('SpicyAirSinkToken');

            // If thing does not contain a tracker, skip.
            if (!(sourceAmt || sinkAmt)) continue;

            let canSeePlayer = mo.CheckSight(plr);
            let dist = max(Double.EPSILON, plr.Distance3D(mo));

            if (canSeePlayer || losFactor > 0) {
                if (sinkAmt) {
                    let toAdd = calcDist(
                        sinkAmt
                            * ((mo.scale.x + mo.scale.y) / 2.0)
                            * (canSeePlayer ? 1.0 : (losFactor / 100.0)),
                        _spicySinkDistance.GetFloat(),
                        dist
                    );

                    if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_TRACE, "Adding Spicy Air Sink: "..mo.getClassName().." @ "..mo.pos..", -"..toAdd.."x spiciness");

                    activeSinks = max(toAdd, activeSinks);
                    countSinks++;
                } else if (sourceAmt) {
                    let toAdd = calcDist(
                        sourceAmt
                            * ((mo.scale.x + mo.scale.y) / 2.0)
                            * (canSeePlayer ? 1.0 : (losFactor / 100.0)),
                        _spicySourceDistance.GetFloat(),
                        dist
                    );

                    if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_TRACE, "Adding Spicy Air Source: "..mo.getClassName().." @ "..mo.pos..", +"..toAdd.."x spiciness");
                    
                    activeSources = max(toAdd, activeSources);
                    countSources++;
                }
            }
        }
        if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_TRACE, "END AIR SPICINESS CALCULATION:");

        let airSpiciness = activeSources - activeSinks; // (countSources > 0 ? activeSources / countSources : 0) - (countSinks > 0 ? activeSinks / countSinks : 0);

        if (!(Level.time % TICRATE)) HDCore.log(
            'SpicyAir.SpicyAirHandler', LOGGING_DEBUG, "Current Spicy Air Status:\n"
            .." * Spicy Sources: "..activeSources.."\n"
            .." * Spicy Sinks: "..activeSinks.."\n"
            .." * Air Spiciness: "..airSpiciness
        );

        return airSpiciness;
    }

    private double calcDist(double amount, double factor, double dist) {
        if (!(Level.time % TICRATE)) HDCore.log('SpicyAir.SpicyAirHandler', LOGGING_TRACE, "Calculating distance: ("..amount..", "..factor..", "..dist..")...");

        let af = amount * factor;
        let aff = af * factor;
        let denom = clamp(dist, 1.0, af);

        switch (_distCalc.GetInt()) {
            case SADC_INVERSE_SQUARE:
                return af / (denom * denom);
            case SADC_INVERSE_SQRT:
                return (af / sqrt(denom)) - sqrt(max(1.0, af));
            case SADC_REVERSE_LOG:
                return (amount / factor) * max(0.0, log10(max(1.0, aff - dist)));
            case SADC_REVERSE_SQRT:
                return (amount / factor) * sqrt(max(0.0, aff - dist)) / sqrt(max(1.0, amount));
            case SADC_LINEAR:
            default:
                return clamp((aff - dist) / max(1.0, factor * factor), 0.0, Double.MAX);
        }
    }
}


enum SPICY_DISTANCE_CALCS {
    SADC_INVERSE_SQRT,
    SADC_INVERSE_SQUARE,
    SADC_REVERSE_LOG,
    SADC_REVERSE_SQRT,
    SADC_LINEAR
}
