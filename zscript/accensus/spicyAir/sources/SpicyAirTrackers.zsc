class SpicyAirDummy : IdleDummy abstract {

    name tokenName; property tokenName:tokenName;

    default {
        health 100;
    }

    override void postBeginPlay() {

        super.postBeginPlay();

        // If we can't find the handler, quit.
        let handler = SpicyAirHandler(StaticEventHandler.find('SpicyAirHandler'));
        if (!handler) {
            destroy();
            return;
        }

        // If we spawned in a blacklisted map, quit.
        forEach (bl : handler.mapBlacklist) {
            if (Level.mapName == bl) {
                destroy();
                return;
            }
        }

        if (!(countInv('SpicyAirSourceToken') || countInv('SpicyAirSinkToken'))) A_GiveInventory(tokenName, spawnHealth());
    }
}

class SpicyAirSource : SpicyAirDummy {
    default {
        SpicyAirDummy.tokenName 'SpicyAirSourceToken';
    }
}

class SpicyAirSink : SpicyAirDummy {
    default {
        SpicyAirDummy.tokenName 'SpicyAirSinkToken';
    }
}


class SpicyAirTrackerToken : Inventory abstract {

    default {
        +Inventory.UNTOSSABLE;
    }

    override void Tick() {
        super.Tick();

        amount = GetAmount();
    }

    abstract int GetAmount();
}

class SpicyAirSinkToken : SpicyAirTrackerToken {

    override int GetAmount() {
        return owner.spawnHealth();
    }
}

class SpicyAirSourceToken : SpicyAirTrackerToken {

    protected transient CVar _enabled;
    protected transient CVar _particleMult;
    protected transient CVar _distanceMult;
    protected transient CVar _maxSpiciness;
    protected transient CVar _shieldsSpicySources;

    override void PostBeginPlay() {
        super.PostBeginPlay();

        if (!_enabled) _enabled                         = CVar.GetCVar('spicy_enabled');
        if (!_particleMult) _particleMult               = CVar.GetCVar('spicy_particle_mult');
        if (!_distanceMult) _distanceMult               = CVar.GetCVar('spicy_source_distance');
        if (!_maxSpiciness) _maxSpiciness               = CVar.GetCVar('spicy_max_spiciness');
        if (!_shieldsSpicySources) _shieldsSpicySources = CVar.GetCVar('spicy_sources_shields');
    }

    override int GetAmount() {
        if (!owner) return 0;

        if (owner is 'HDMobBase' && HDMobBase(owner).maxshields > 0 && _shieldsSpicySources && _shieldsSpicySources.GetBool()) return owner.countInv('HDMagicShield');

        return owner.spawnHealth();
    }

    override void Tick() {
        super.Tick();

        // If Spicy Air is currently disabled, don't spawn VFX particles
        if (!(_enabled &&_enabled.GetBool())) return;

        let maxSpiciness = _maxSpiciness ? _maxSpiciness.GetInt() : 0;

        // If Max Spiciness is below valid amount, don't spawn VFX particles.
        if (maxSpiciness <= 0) return;

        let particleMult = _particleMult ? _particleMult.GetFloat() : 0.0;

        // If Particle Multiplier is below valid amount, don't spawn VFX particles.
        if (particleMult <= 0.0) return;

        let distanceMult = _distanceMult ? _distanceMult.GetFloat() : 0.0;

        // If Distance Multiplier is below valid amount, don't spawn VFX particles.
        if (distanceMult <= 0.0) return;

        // If owner is dead, don't spawn VFX particles
        if (HDMath.isDead(owner)) return;

        // If owner is either outside of or too far from the current player's POV
        if (!(owner.distance3D(players[ConsolePlayer].camera) < HDCONST_ONEMETRE * 20 && HDF.checkParticle(owner))) return;

        let ratio = double(amount * TICRATE / max(1, Level.airSupply));
        if (frandom[spicyrand](0.0, 1.0) < clamp(ratio, 0.0, 1.0)) {

            let particleCount = ratio * maxSpiciness * particleMult;
            for (let i = 0; i < particleCount; i++) {

                let dist = HDCONST_ONEMETRE * max(1, ceil(i / distanceMult)) * distanceMult;
                Vector3 pos = owner.pos + (
                    frandom[spicyrand](-dist, dist),
                    frandom[spicyrand](-dist, dist),
                    frandom[spicyrand](-dist, dist)
                );
    
                // If the spawnPos is outside the level, skip.
                if (!Level.isPointInLevel(pos)) continue;
    
                let lifetime = random[spicyrand](27, 88) * 2.0;
                let vel = (frandom[spicyrand](-0.4, 0.4), frandom[spicyrand](-0.4, 0.4), frandom[spicyrand](-0.4, 0.4));
                let accel = ((frandom[spicyrand](-0.4, 0.4), frandom[spicyrand](-0.4, 0.4), frandom[spicyrand](-0.4, 0.4)) - vel) / lifetime;
    
                HDF.Particle(
                    owner,
                    0xa7b55e,
                    pos,
                    lifetime: lifetime,
                    size: 2.0,
                    vel: vel,
                    fullBright: true,
                    accel: accel
                );
            }
        }
    }
}